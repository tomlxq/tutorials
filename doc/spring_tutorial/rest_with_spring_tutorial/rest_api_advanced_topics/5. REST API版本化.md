# REST API版本化

## 1.问题
不断发展的REST API是一个棘手的问题-有很多可用的选择。 本文讨论了其中一些选项。
## 2.合同中有什么？
首先，我们需要回答一个简单的问题：API和客户端之间的合同是什么？

### 2.1 URI是合同的一部分吗？
首先让我们考虑一下REST API的URI结构-这是合同的一部分吗？客户应该添加书签，硬编码并通常依赖于API的URI吗？

如果是这种情况，则客户端与REST服务的交互将不再由服务本身驱动，而是由Roy Fielding所谓的带外信息驱动：

> 输入REST API时，除了最初的URI（书签）和适用于目标受众的标准化媒体类型集之外，不应具有其他先验知识。这里的失败表示带外信息正在驱动交互，而不是超文本。
>
> A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience…Failure here implies that out-of-band information is driving interaction instead of hypertext.

显然，URI不是合同的一部分！客户端应该只知道一个URI – API的入口点。使用API时应发现所有其他URI。

### 2.2 合同的媒体类型部分？
用于资源表示的媒体类型信息又如何？这些是客户与服务之间合同的一部分吗？

为了成功使用API，客户端必须具有这些媒体类型的先验知识。实际上，这些媒体类型的定义代表整个合同。

因此，这是REST服务应重点关注的地方：

> REST API应该花费几乎所有的描述性精力来定义用于表示资源和驱动应用程序状态的媒体类型，或者为现有标准媒体类型定义扩展关系名称和/或启用超文本的标记。
>
> A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.

因此，媒体类型定义是合同的一部分，对于使用API的客户端来说应该是先验知识。这就是标准化的源泉。

现在，我们对合同是什么有了一个好主意，让我们继续探讨如何实际解决版本问题。

## 3.高级选项
现在让我们讨论对REST API进行版本控制的高级方法：

* URI版本控制–使用版本指示符对URI空间进行版本控制
* 媒体类型版本控制–版本化资源的表示形式

当我们在URI空间中引入版本时，资源表示被认为是不可变的。因此，当需要在API中引入更改时，需要创建一个新的URI空间。


例如，假设某个API发布了以下资源-用户和特权：

```
http://host/v1/users
http://host/v1/privileges
```

现在，让我们考虑一下用户API的重大变化需要引入第二个版本：

```
http://host/v2/users
http://host/v2/privileges
```

在对媒体类型进行版本化和扩展语言时，我们将基于此标头进行内容协商。 REST API将使用自定义供应商MIME媒体类型，而不是诸如application / json之类的通用媒体类型。我们将对这些媒体类型而不是URI进行版本控制。

例如：

```
===>
GET /users/3 HTTP/1.1
Accept: application/vnd.myname.v1+json
<===
HTTP/1.1 200 OK
Content-Type: application/vnd.myname.v1+json
{
    "user": {
        "name": "John Smith"
    }
}
```

我们可以查看此“ Rest API的自定义媒体类型”文章，以获取有关此主题的更多信息和示例。

在这里要理解的重要一点是，除了媒体类型中定义的内容外，客户端不会对响应的结构做出任何假设。

这就是为什么通用媒体类型不理想的原因。这些没有提供足够的语义信息，并且迫使客户端使用需要额外的提示来处理资源的实际表示。

唯一的例外是使用其他方式来唯一标识内容的语义，例如XML模式。

## 4.优缺点
现在，我们对客户端与服务之间的合同的组成部分有一个清晰的概念，并且对API版本的选择进行了高级概述，下面我们来讨论每种方法的优缺点。

首先，在URI中引入版本标识符会导致很大的URI占用空间。这是由于以下事实：在任何已发布的API中进行的任何重大更改都会引入整个API的全新表示树。随着时间的流逝，这将成为维护的负担，同时也给客户带来了麻烦-客户现在有更多选择。

URI中的版本标识符也非常不灵活。无法简单地开发单个资源或整个API的一小部分的API。

如前所述，这是一种全有或全无的方法。如果API的一部分移至新版本，则整个API必须随之移动。这也使将客户端从v1升级到v2成为一项重要的任务-这导致升级速度较慢，旧版本的停用期更长。

关于版本控制，HTTP缓存也是一个主要问题。

从中间的代理缓存的角度来看，每种方法都有优点和缺点。如果对URI进行了版本控制，则缓存将需要保留每个资源的多个副本-每个API版本都应保留一个副本。由于不同的客户端将使用不同的版本，因此这会增加缓存的负载并降低缓存的命中率。

此外，某些缓存失效机制将不再起作用。如果介质类型是已版本化的介质类型，则客户端和服务都需要支持Vary HTTP标头以指示有多个版本正在缓存。

但是，从客户端缓存的角度来看，对媒体类型进行版本控制的解决方案比URI中包含版本标识符的解决方案涉及的工作要稍微多一些。这是因为，当键为URL时，比媒体类型更容易缓存某些内容。

让我们以定义一些目标（直接从API Evolution）结束本节：

* 保持兼容更改的名称
* 避免使用新的主要版本
* 向后兼容
* 考虑前向兼容性

## 5. API的可能更改
接下来，让我们考虑一下REST API的更改类型-此处介绍了这些更改：

表示格式更改
资源变化
### 5.1 添加到资源的表示形式
媒体类型的格式文档在设计时应考虑向前兼容性。具体来说，客户端应忽略其无法理解的信息（哪种JSON比XML更好）。

现在，如果正确实现了现有客户端，则在资源表示中添加信息不会破坏现有客户端。

继续前面的示例，在用户表示形式中添加金额将不是一个重大更改：

```json
{
    "user": {
        "name": "John Smith", 
        "amount": "300"
    }
}
```

### 5.2 删除或更改现有的表示形式
在现有表示形式的设计中删除，重命名或总体上重组信息对于客户而言是一项重大变化。这是因为他们已经了解并依赖旧格式。




这是内容协商的来源。对于此类更改，我们可以添加新的供应商MIME媒体类型。

让我们继续前面的示例。假设我们想将用户名分为名字和姓氏：

```
===>
GET /users/3 HTTP/1.1
Accept: application/vnd.myname.v2+json
<===
HTTP/1.1 200 OK
Content-Type: application/vnd.myname.v2+json
{
    "user": {
        "firstname": "John", 
        "lastname": "Smith", 
        "amount": "300"
    }
}
```

因此，这确实代表了客户端的不兼容更改-必须请求新的表示形式并理解新的语义。但是，URI空间将保持稳定并且不会受到影响。

### 5.3 重大语义变化
这些是资源含义，它们之间的关系或后端映射的变化。这种更改可能需要新的媒体类型，或者可能需要在旧的媒体资源旁边发布新的同级资源，并利用链接指向它。

虽然这听起来像是在URI中再次使用版本标识符，但重要的区别在于，新资源是独立于API中的任何其他资源发布的，并且不会将整个API派生到根目录。

REST API应该遵守HATEOAS约束。据此，大多数URI应该由客户端发现，而不是硬编码。更改此类URI不应被视为不兼容的更改。新的URI可以替代旧的URI，客户端将能够重新发现URI并继续运行。

但是，值得注意的是，尽管由于所有这些原因，在URI中使用版本标识符是有问题的，但它绝不是非RESTful的。

## 6. 结论
本文试图概述REST服务演变过程中非常多样化和棘手的问题。 我们讨论了两种常见的解决方案，每种解决方案的优缺点以及在REST上下文中推理这些方法的方法。

本文的结尾是为第二种解决方案辩护-在检查RESTful API的可能更改的同时对媒体类型进行版本控制。

可以在GitHub项目中找到本教程的完整实现。