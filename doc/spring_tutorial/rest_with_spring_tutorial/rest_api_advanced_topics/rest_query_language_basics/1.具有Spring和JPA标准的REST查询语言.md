# 具有Spring和JPA标准的REST查询语言

## 1.概述
在这个新系列的第一篇文章中，我们将探索一种REST API的简单查询语言。 我们将在REST API中充分利用Spring，并在持久性方面充分利用JPA 2 Criteria。

为什么使用查询语言？ 因为–对于任何足够复杂的API来说，仅通过非常简单的字段搜索/过滤资源都是远远不够的。 查询语言更加灵活，可让您精确过滤所需的资源。

## 2.用户实体
首先-让我们提出一个用于过滤器/搜索API的简单实体-基本用户：

```java
@Entity
@NoArgsConstructor
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String firstName;

    private String lastName;

    private String email;

    private int age;
}
```

## 3.使用CriteriaBuilder进行过滤
现在-让我们深入研究问题-持久层中的查询。

建立查询抽象是一个平衡问题。一方面，我们需要大量的灵活性，另一方面，我们需要保持复杂性可管理。高层，功能很简单–传递一些约束，然后返回一些结果。

让我们看看它是如何工作的：

```java
@Repository
public class UserDAO implements IUserDAO {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<User> searchUser(final List<SearchCriteria> params) {
        final CriteriaBuilder builder = entityManager.getCriteriaBuilder();
        final CriteriaQuery<User> query = builder.createQuery(User.class);
        final Root r = query.from(User.class);

        Predicate predicate = builder.conjunction();
        UserSearchQueryCriteriaConsumer searchConsumer = new UserSearchQueryCriteriaConsumer(predicate, builder, r);
        params.stream().forEach(searchConsumer);
        predicate = searchConsumer.getPredicate();
        query.where(predicate);

        return entityManager.createQuery(query).getResultList();
    }

    @Override
    public void save(final User entity) {
        entityManager.persist(entity);
    }
}
```

让我们看一下UserSearchQueryCriteriaConsumer类：

```java
@AllArgsConstructor
public class UserSearchQueryCriteriaConsumer implements Consumer<SearchCriteria>{
    private Predicate predicate;
    private CriteriaBuilder builder;
    private Root r;
    @Override
    public void accept(SearchCriteria param) {
        if (param.getOperation().equalsIgnoreCase(">")) {
            predicate = builder.and(predicate, builder.greaterThanOrEqualTo(r.get(param.getKey()), param.getValue().toString()));
        } else if (param.getOperation().equalsIgnoreCase("<")) {
            predicate = builder.and(predicate, builder.lessThanOrEqualTo(r.get(param.getKey()), param.getValue().toString()));
        } else if (param.getOperation().equalsIgnoreCase(":")) {
            if (r.get(param.getKey()).getJavaType() == String.class) {
                predicate = builder.and(predicate, builder.like(r.get(param.getKey()), "%" + param.getValue() + "%"));
            } else {
                predicate = builder.and(predicate, builder.equal(r.get(param.getKey()), param.getValue()));
            }
        }
    }
    public Predicate getPredicate() {
        return predicate;
    }
}
```

如您所见，searchUser API接受非常简单的约束的列表，根据这些约束组成查询，进行搜索并返回结果。

约束类也非常简单：

```java
@NoArgsConstructor
@AllArgsConstructor
@Data
public class SearchCriteria {
    private String key;
    private String operation;
    private Object value;
}
```

SearchCriteria实现包含我们的查询参数：

* key：用于保存字段名称-例如：firstName，age等。
* operation：用于保持操作–例如：等于，小于，…等。
* value：用于保存字段值，例如：john，25，…等。