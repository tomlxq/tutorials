# Spring中理解 getBean() 

## 1.简介
在本教程中，我们将介绍BeanFactory.getBean（）方法的不同变体。

简而言之，正如方法名称所暗示的那样，这负责从Spring容器中检索bean实例。

## 2. Spring Beans安装
首先，让我们定义一些Spring bean进行测试。 我们可以通过多种方式为Spring容器提供bean定义，但是在我们的示例中，我们将使用基于注释的Java配置：

```java
@Configuration
class AnnotationConfig {
 
    @Bean(name = {"tiger", "kitty"})
    @Scope(value = "prototype")
    Tiger getTiger(String name) {
        return new Tiger(name);
    }
 
    @Bean(name = "lion")
    Lion getLion() {
        return new Lion("Hardcoded lion name");
    }
 
    interface Animal {}
}
```

我们创建了两个bean。 Lion具有默认的单例作用域。 Tiger已明确设置为原型范围。 此外，请注意，我们为将在以后的请求中使用的每个bean定义了名称。

## 3. getBean（）API
BeanFactory提供了getBean（）方法的五个不同签名，我们将在以下小节中进行研究。

### 3.1 通过名称检索Bean
让我们看看如何使用其名称检索Lion Bean实例：

```java
Object lion = context.getBean("lion");

assertEquals(lion.getClass(), Lion.class);
```

在此变体中，我们提供一个名称，如果应用程序上下文中存在具有给定名称的bean，则返回Object类的实例。 否则，如果bean查找失败，则此实现和所有其他实现都将引发NoSuchBeanDefinitionException。

```java
@Test
void whenGivenNonExistingBeanName_shouldThrowException() {
    assertThrows(NoSuchBeanDefinitionException.class, () -> context.getBean("non-existing"));
}
```

主要缺点是，在检索bean之后，我们必须将其转换为所需的类型。 如果返回的bean具有与我们预期不同的类型，则这可能会产生另一个异常。

假设我们尝试使用“狮子”这个名字来获得老虎。 当我们将结果转换为Tiger时，它将抛出ClassCastException：

```java
@Test
void whenCastingToWrongType_thenShouldThrowException() {
    assertThrows(ClassCastException.class, () -> {
        Tiger tiger = (Tiger) context.getBean("lion");
    });
}
```

### 3.2 通过名称和类型检索Bean
在这里，我们需要指定所请求bean的名称和类型：

```java
@Test
void whenSpecifiedMatchingNameAndType_thenShouldReturnRelatedBean() {
    Lion lion = context.getBean("lion", Lion.class);

    assertEquals("Hardcoded lion name", lion.getName());
}
```

与以前的方法相比，此方法更安全，因为我们可以立即获得有关类型不匹配的信息：

```java
@Test
void whenSpecifiedNotMatchingNameAndType_thenShouldThrowException() {
    assertThrows(BeanNotOfRequiredTypeException.class, () -> context.getBean("lion", Tiger.class));
}
```