# Spring框架的Http消息转换器

## 1.概述
本文介绍如何在Spring中配置HttpMessageConverters。

简而言之，我们可以使用消息转换器通过HTTP将Java对象与JSON，XML等进行编组和解组。

## 2.基础知识
### 2.1 启用Web MVC

首先，需要为Web应用程序配置Spring MVC支持。 一种方便且可自定义的方法是使用@EnableWebMvc批注：

```java
@EnableWebMvc
@Configuration
@ComponentScan({ "com.tom.web" })
public class WebConfig implements WebMvcConfigurer {
    //...
}
```

请注意，该类实现了WebMvcConfigurer-这将使我们能够使用自己的方法更改Http转换器的默认列表。

### 2.2 默认消息转换器
默认情况下，以下HttpMessageConverters实例是预启用的：

ByteArrayHttpMessageConverter –转换字节数组
StringHttpMessageConverter –转换字符串
ResourceHttpMessageConverter –将org.springframework.core.io.Resource转换为任何类型的八位字节流
SourceHttpMessageConverter –转换javax.xml.transform.Source
FormHttpMessageConverter –将表单数据与MultiValueMap <String，String>之间进行转换。
Jaxb2RootElementHttpMessageConverter –将Java对象与XML之间进行转换（仅当类路径中存在JAXB2时才添加）
MappingJackson2HttpMessageConverter –转换JSON（仅在类路径中存在Jackson 2时添加）
MappingJacksonHttpMessageConverter –转换JSON（仅在类路径中存在Jackson时添加）
AtomFeedHttpMessageConverter –转换Atom提要（仅在类路径中存在Rome时添加）
RssChannelHttpMessageConverter –转换RSS源（仅在类路径中存在Rome时添加）

## 3. 客户端-服务器通信–仅JSON
### 3.1 高级内容协商
每个HttpMessageConverter实现都有一个或多个关联的MIME类型。

当接收到一个新请求时，Spring将使用“ Accept”标头来确定它需要响应的媒体类型。

然后它将尝试找到能够处理该特定媒体类型的注册转换器。最后，它将使用它来转换实体并发送回响应。

接收包含JSON信息的请求的过程与之类似。框架将使用“ Content-Type”标头来确定请求主体的媒体类型。

然后它将搜索HttpMessageConverter，该消息可以将客户端发送的正文转换为Java对象。

让我们用一个简单的例子来澄清一下：

* 客户端向/ foos发送一个GET请求，并将Accept标头设置为application / json –以JSON格式获取所有Foo资源
* 点击Foo Spring Controller并返回相应的Foo Java实体
* 然后，Spring使用Jackson消息转换器之一将实体编组为JSON

现在，让我们看一下它如何工作的细节以及如何利用@ResponseBody和@RequestBody批注。

### 3.2 @ResponseBody
Controller方法上的@ResponseBody向Spring指示该方法的返回值直接序列化到HTTP Response的主体。 如上所述，客户端指定的“ Accept”标头将用于选择适当的Http Converter来编组实体。


让我们看一个简单的例子：

```java
@GetMapping("/{id}")
public @ResponseBody Foo findById(@PathVariable long id) {
    return fooService.findById(id);
}
```

现在，客户端将在请求中为application / json指定“ Accept”标头– curl命令示例：

`curl --header "Accept: application/json" http://localhost:8080/spring-boot-rest/foos/1`
Foo类：

```java
@XStreamAlias("Foo")
@Entity
@Data
@NoArgsConstructor
public class Foo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    @Column(nullable = false)
    private String name;
  
    @Version
    private long version;
    public Foo(final String name) {
        super();

        this.name = name;
    }
}
```

和Http响应正文：

```json
{
    "id": 1,
    "name": "Paul",
}
```

