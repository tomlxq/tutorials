# JVM，JRE和JDK之间的区别

## 1. 概述
在本文中，我们将通过考虑JVM，JRE和JDK的组件和用途来讨论它们之间的区别。

## 2. JVM
Java虚拟机（Java Virtual Mechine JVM）是执行Java程序的虚拟机的实现。
JVM首先解释字节码。 然后，存储类信息在存储区。 最后，它执行Java编译器生成的字节码。
它是一台抽象计算机，具有自己的指令集，并在运行时处理各种内存区域。
JVM的组件包括：
* 类加载器 Class Loader
* 运行时数据区 Run-time Data Area
* 执行引擎 Execution Engine

### 2.1 类加载器
JVM的初始任务包括加载，验证和链接字节码。 类加载器处理这些任务。

我们有专门针对[类加载器的详细文章](4.Java中的类加载器.md)。

### 2.2 运行时数据区
JVM定义了各种内存区域来执行Java程序。 这些在运行时期间使用，称为运行时数据区域。 其中一些区域是在JVM启动时创建的，在JVM退出时会被破坏，而某些区域在创建线程时会创建，而在线程退出时会被破坏。

让我们一一了解这些区：

* 方法区 Method Area

  基本上，方法区域类似于编译代码的存储区域。 它存储结构，例如运行时常量池，字段和方法数据，方法和构造函数的代码以及完全限定的类名。 JVM为每个类存储这些结构。

  在JVM启动时创建方法区域，也称为永久代（PermGen）。 该区域的内存不必是连续的。 所有JVM线程共享此内存区域。

* 堆区 Heap Area

  JVM为该区域中的所有类实例和数组分配内存。

  垃圾收集器（GC）回收对象的堆内存。 基本上，GC具有三个阶段来从对象通过两个次要GC（Miner GC）和一个主要GC（Main GC）回收内存。

  堆内存分为三个部分：

  * 伊甸园空间（Eden Space）–它是年轻代空间（Young Generation Space）的一部分。 当我们创建一个对象时，JVM从该空间分配内存
  * 幸存者空间（Servivor Space）-它也是年轻代空间（Young Generation Space）的一部分。 幸存者空间包含在GC的次要GC阶段中幸存的现有对象
  * 终身空间（Tenured Space）–也称为老年代空间（Old Generation Space）。 它拥有长期存活的对象。 基本上，为“年轻代”对象设置一个阈值，当达到该阈值时，这些对象将移至终身空间。
  
  JVM一启动就会创建堆区域。 JVM的所有线程共享该区域。 堆区域的内存不必是连续的。

* 堆栈区 Stack Area

  将数据存储为帧，每帧存储局部变量，部分结果和嵌套方法调用。 JVM每当创建新线程时都会创建堆栈区域。 该区域是每个线程专用的。

  堆栈中的每个条目都称为堆栈帧或激活记录。 每个帧包含三个部分：

  * 局部变量数组（Local Variable Array）–包含方法的所有局部变量和参数
  * 操作数堆栈（Operand Stack）–用作存储中间计算结果的工作空间
  * 帧数据（Frame Data） - 用于存储部分结果，对于方法返回值，并参照异常表提供对应于异常的情况下catch块信息
  
  JVM堆栈的内存不必是连续的。

* PC寄存器 PC Register

  每个JVM线程都有一个单独的PC寄存器，用于存储当前正在执行的指令的地址。 如果当前执行的指令是本机方法的一部分，则此值未定义。

* 本机方法堆栈 Native Method Stack

  本机方法是用Java以外的语言编写的方法。

  JVM提供了调用这些本机方法的功能。 本机方法堆栈也称为“ C堆栈”。 它们存储本机方法信息。 每当将本机方法编译为机器代码时，它们通常会使用本机方法堆栈来跟踪其状态。

  每当创建新线程时，JVM都会创建这些堆栈。 因此，JVM线程不共享该区域。

### 2.3 执行引擎
执行引擎使用存储区中存在的信息执行指令。它分为三个部分：

* 解释器 Interpreter

  一旦类加载器加载并验证了字节码，解释器便逐行执行字节码。执行速度很慢。解释器的缺点是，当多次调用一种方法时，每次都需要新的解释。

  但是，JVM使用JIT编译器来减轻此缺点。

* 即时（JIT）编译器 Just In-Time Compiler

  JIT编译器在运行时将常用方法的字节码编译为本机代码。因此，它负责Java程序的优化。

  JVM自动监视正在执行的方法。一旦方法可以进行JIT编译，就可以计划将其编译为机器代码。这种方法被称为热方法。编译为机器代码的过程发生在单独的JVM线程上。


  结果，它不会中断当前程序的执行。编译成机器代码后，它运行得更快。

* 垃圾收集器 Garbage Collector

  Java使用Garbage Collection负责内存管理。它是查看堆内存，确定正在使用哪些对象以及哪些没有使用的对象，最后删除未使用的对象的过程。

  GC是守护程序线程。可以使用System.gc（）方法显式调用它，但是不会立即执行，并且JVM决定何时调用GC。

### 2.4 Java本机接口
它充当Java代码和本机（C / C ++）库之间的接口。

在某些情况下，仅Java不能满足您的应用程序需求，例如，实现依赖于平台的功能。

在这种情况下，我们可以使用JNI启用在JVM中运行的代码来调用。 相反，它使本机方法可以调用在JVM中运行的代码。

### 2.5 本机库
这些是平台特定的库，包含本机方法的实现。

## 3. JRE
Java Runtime Environment（JRE）是用于运行Java应用程序的一组软件组件。

JRE的核心组件包括：

* Java虚拟机（JVM）的实现
* 运行Java程序所需的类
* 属性文件

我们在上一节中讨论了JVM。 在这里，我们将重点介绍核心类和支持文件。

### 3.1 引导类
我们将在jre / lib /下找到引导类。 此路径也称为引导类路径。 这包括：

* rt.jar中的运行时类
* i18n.jar中的国际化类
* charsets.jar中的字符转换类
* 其他

Bootstrap ClassLoader在JVM启动时加载这些类。

### 3.2 扩展类
我们可以在jre / lib / extn /中找到扩展类，它充当Java平台扩展的目录。 此路径也称为扩展类路径。

它在jfxrt.jar中包含JavaFX运行时库，在localedata.jar中包含java.text和java.util包的语言环境数据。 用户还可以将自定义jar添加到此目录中。

### 3.3 属性设置
Java平台使用这些属性设置来维护其配置。 根据它们的用法，它们位于/ jre / lib /中的不同文件夹中。 这些包括：

* calendar.properties中的日历配置
* logging.properties中的日志记录配置
* net.properties中的网络配置
* / jre / lib / deploy /中的部署属性
* / jre / lib / management /中的管理属性

### 3.4 其它文件
除了上述文件和类之外，JRE还包含用于其他事项的文件：

* 位于jre / lib / security的安全管理
* 用于将小程序的支持类放置在jre / lib / applet的目录
* 与字体相关的文件位于jre / lib / fonts等

## 4. JDK
Java开发工具包（JDK）提供了用于开发，编译，调试和执行Java程序的环境和工具。

JDK的核心组件包括：

* JRE
* 开发工具

我们在上一节中讨论了JRE。

现在，我们将重点介绍各种开发工具。 让我们根据使用情况对这些工具进行分类：

### 4.1 基本工具
这些工具奠定了JDK的基础，并用于创建和构建Java应用程序。在这些工具中，我们可以找到用于编译，调试，归档，生成Javadocs等的实用程序。


它们包括：

* javac –读取类和接口定义，并将其编译为类文件
* java –启动Java应用程序
* javadoc –从Java源文件生成API文档的HTML页面
* apt –根据指定的源文件集中存在的注释查找并执行注释处理器
* appletviewer –使我们无需网络浏览器即可运行Java applet
* jar –将Java applet或应用程序打包到单个存档中
* jdb –一种命令行调试工具，用于查找和修复Java应用程序中的错误
* javah –从Java类生成C头文件和源文件
* javap –分解类文件，并显示有关类文件中存在的字段，构造函数和方法的信息
* extcheck –检测目标Java存档（JAR）文件与当前安装的扩展JAR文件之间的版本冲突

### 4.2 安全工具
其中包括用于操作Java密钥库的密钥和证书管理工具。

Java密钥库是用于授权证书或公共密钥证书的容器。因此，基于Java的应用程序通常将其用于加密，身份验证和通过HTTPS服务。

此外，它们还有助于在我们的系统上设置安全策略并创建可以在生产环境中这些策略的范围内工作的应用程序。这些包括：

* keytool –帮助管理密钥库条目，即加密密钥和证书
* jarsigner –使用密钥库信息生成经过数字签名的JAR文件
* policytool –使我们能够管理定义安装的安全策略的外部策略配置文件

一些安全工具还有助于管理Kerberos票证。
Kerberos是一种网络身份验证协议。
它基于票证工作，以允许通过非安全网络进行通信的节点以安全方式相互证明其身份：

* kinit –用于获取和缓存授予Kerberos票证的票证
* ktab –管理密钥表中的主体名称和密钥对
* klist –在本地凭据缓存和密钥表中显示条目

### 4.3 国际化工具
国际化是设计应用程序的过程，这样它可以在不进行工程更改的情况下适应各种语言和地区。

为此，JDK带来了native2ascii。 该工具将具有JRE支持的字符的文件转换为以ASCII或Unicode转义编码的文件。

### 4.4 远程方法调用（RMI）工具
RMI工具支持Java应用程序之间的远程通信，从而为分布式应用程序的开发提供了空间。

RMI使运行在一个JVM中的对象能够调用运行在另一个JVM中的对象上的方法。 这些工具包括：

* rmic –使用Java远程方法协议Java Remote Method Protocol（JRMP）或Internet Inter-Orb Protocol（IIOP）为远程对象生成stub，skeleton和tie类
* rmiregistry –创建并启动远程对象注册表
* rmid –启动激活系统守护程序。 这允许在Java虚拟机中注册和激活对象
* serialver –返回指定类的串行版本UID

### 4.5 Java IDL和RMI-IIOP工具
Java接口定义语言（IDL）向Java平台添加了基于对象的通用请求代理体系结构（CORBA）。

这些工具使分布式Java Web应用程序可以使用行业标准的对象管理组（OMG）– IDL调用远程网络服务上的操作。

同样，我们可以使用Internet InterORB协议（IIOP）。

RMI-IIOP，即基于IIOP的RMI，可以通过RMI API对CORBA服务器和应用程序进行编程。因此，可以通过Internet InterORB协议（IIOP）在以任何CORBA兼容语言编写的两个应用程序之间建立连接。

这些工具包括：

* tnameserv –临时命名服务，提供树结构目录供对象引用
* idlj – IDL到Java编译器，用于为指定的IDL文件生成Java绑定
* orbd –使客户端能够在CORBA环境中透明地定位和调用服务器上的持久对象
* servertool –提供命令行界面以在ORB Daemon（orbd）中注册或注销持久性服务器，启动和关闭在ORB Daemon中注册的持久性服务器，等等。

### 4.6 Java部署工具
这些工具有助于在Web上部署Java应用程序和小程序。 它们包括：

pack200 –使用Java gzip压缩器将JAR文件转换为pack200文件
unpack200 –将pack200文件转换为JAR文件

### 4.7 Java插件工具
JDK为我们提供了htmlconverter。 此外，它与Java插件结合使用。

一方面，Java插件在流行的浏览器和Java平台之间建立了连接。 作为这种连接的结果，网站上的小程序可以在浏览器中运行。

另一方面，htmlconverter是用于将包含小程序的HTML页面转换为Java插件格式的实用程序。

### 4.8 Java Web启动工具
JDK带来了Javaws。 我们可以将其与Java Web Start结合使用。

该工具使我们能够从浏览器中单击下载并启动Java应用程序。 因此，无需运行任何安装过程。

### 4.9 监控和管理工具
这些是很棒的工具，我们可以用来监视JVM性能和资源消耗。 以下是其中一些：

* jconsole –提供一个图形控制台，可让您监视和管理Java应用程序
* jps –列出目标系统上已检测的JVM
* jstat –监视JVM统计信息
* jstatd –监视检测的JVM的创建和终止

### 4.10 故障排除工具
这些是实验性工具，我们可以利用它们来进行故障排除任务：

* info –为指定的Java进程生成配置信息
* jmap –显示指定进程的共享对象内存映射或堆内存详细信息
* jsadebugd –附加到Java进程并充当调试服务器
* jstack –为给定的Java进程打印Java线程的Java堆栈跟踪

## 5.结论
在本文中，我们确定了JVM，JRE和JDK之间的基本区别在于它们的用法。

首先，我们描述了JVM是如何实际上执行Java字节码的抽象计算机。

然后，我们解释了如何使用JRE运行Java应用程序。

最后，我们了解了如何使用JDK开发Java应用程序。

我们还花了一些时间来研究此组件的工具和基本概念。