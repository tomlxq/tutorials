# 用Spring服务静态资源

## 1.概述
本文探讨了如何通过XML和Java配置在Spring中提供静态资源。

## 2.使用Spring Boot
Spring Boot随附了ResourceHttpRequestHandler的预配置实现，以方便提供静态资源。

默认情况下，此处理程序从类路径上的/ static，/ public，/ resources和/ META-INF / resources目录中的任何一个提供静态内容。 由于src / main / resources通常默认情况下位于类路径中，因此我们可以在其中放置任何这些目录。

例如，如果我们在类路径的/ static目录中放置about.html文件，则可以通过http：// localhost：8080 / about.html访问该文件。 同样，我们可以通过将文件添加到其他提到的目录中来获得相同的结果。

### 2.1 自定义路径模式
默认情况下，Spring Boot在请求的根部分（即/ **）下提供所有静态内容。 即使它似乎是一个很好的默认配置，我们也可以通过spring.mvc.static-path-pattern配置属性进行更改。

例如，如果我们想通过http：// localhost：8080 / content / about.html访问相同的文件，则可以在application.properties中这样说：

`spring.mvc.static-path-pattern=/content/**`
在WebFlux环境中，我们应该使用spring.webflux.static-path-pattern属性。

### 2.2 自定义目录
与路径模式类似，也可以通过spring.resources.static-locations配置属性更改默认资源位置。 此属性可以接受多个逗号分隔的资源位置：

`spring.resources.static-locations=classpath:/files/,classpath:/static-files`
在这里，我们从类路径中的/ files和/ static-files目录提供静态内容。 此外，Spring Boot可以从类路径之外提供静态文件：

`spring.resources.static-locations=file:/opt/files`
在这里，我们使用文件资源签名file：/从本地磁盘提供文件。

## 3. XML配置
如果您需要采用基于XML的配置的旧方式，则可以充分利用mvc：resources元素指向具有特定公共URL模式的资源位置。

例如–通过在我们应用程序根文件夹下的“ / resources /”目录中搜索，以下行将以“ / resources / **”之类的公共URL模式满足所有对资源的请求。

`<mvc:resources mapping="/resources/**" location="/resources/" />`
现在，我们可以在以下HTML页面中访问CSS文件：

示例3.1

```html
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<html>
<head>
    <link href="<c:url value="/resources/myCss.css" />" rel="stylesheet">
    <title>Home</title>
</head>
<body>
    <h1>Hello world!</h1>
</body>
</html>
```

## 4. ResourceHttpRequestHandler
Spring 3.1引入了ResourceHandlerRegistry，以配置ResourceHttpRequestHandlers以便从类路径，WAR或文件系统中提供静态资源。 我们可以在Web上下文配置类中以编程方式配置ResourceHandlerRegistry。

### 4.1 服务WAR中存储的资源
为了说明这一点，我们将使用与以前相同的URL指向myCss.css，但是现在实际文件将位于WAR的webapp / resources文件夹中，这是部署Spring 3.1+应用程序时应放置静态资源的位置。 

```java
@Configuration
@EnableWebMvc
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry
          .addResourceHandler("/resources/**")
          .addResourceLocations("/resources/"); 
    }
}
```

让我们分析示例位。 首先，我们通过添加定义资源处理程序来配置面向外部的URI路径。 然后，我们将该面向外部的URI路径内部映射到资源实际所在的物理路径。

我们当然可以使用这个简单而灵活的API定义多个资源处理程序。

现在– html页面中的以下行将为我们提供webapp / resources目录中的myCss.css资源：

## How to tell Maven to use Java 9

```markup
   <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>9</source>
                    <target>9</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

 

```
mvn clean test -DargLine="--add-modules java.xml.ws.annotation"
```